Reg对象

## 正则表达式匹配规则
* literal character
* meta character
> 1.点字符（.) 匹配除 回车（\r） 换行（\n） 行分隔符  段分隔符之外的所有字符  
> 2.位置字符 ^表示字符串开始的位置  $表示字符串结尾的位置  
> 3.选择符（|）表示关系或OR  
> 4.转义符 `\`      
> 5.字符类表示有一系列字符可供选择，[xyx]表示x，y，z中任选一个匹配。
> > * 脱字符（^） [^xyz]表示除了x，y，z之外都可以匹配 [^]可以匹配任意字符，包括换行符。
> > * 连字符（-） 如[0-9] ,[a-z]提供一种简写形式  


1. 一些预定义模式
> >* \d 匹配0-9之间的任意数字
> >* \D 匹配0-9以外的任意字符
> >* \w 匹配任意字母，数字，下划线
> >* \W 匹配除所有字母，数字，下划线以外的字符
> >* \s 匹配空格（包括换行符，制表符等等）
> >* \S匹配非空格的字符
> >* \b 匹配词的边界，词首必须独立
> >* \B 匹配非词边界，即在词的内部

2. 模式的精确匹配次数，使用大括号（{}）表示{m}.{m-n}
> * 量词符，用来设定某个模式出现的次数
> * ？表示出现0次或一次
> * \*表示出现任意次数 {0，}
> * \+表示出现至少一次{1，}  

3. 量词符默认情况下使用贪婪匹配，表示尽可能多的匹配。如果要使用非贪婪模式，可以在量词符后面加一个？问号
>  修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。可以单个使用，也可以多个使用
>  * g修饰符，表示全局匹配
>  * i修饰符，正则对象本身区分大小写，加上该修饰符以后忽略大小写
>  * m修饰符，表示多行模式（multiline），会修改`^`和`$`的行为，加上m修饰符后，^和$还会匹配行首和行尾。

4. 组匹配。正则表达式用括号来表示分组匹配，括号中的模式可以用来匹配分组的内容
>  * 使用组匹配时，不应该同时使用g修饰符，否则match方法不会捕获分组的内容。
>  * 正则表达式内部还可以使用\n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。  
>  * 非捕获组`(?:x)`表示不返回该组匹配的内容，也就是匹配的结果中不计入这个括号。
>  * 先行断言`x(?=y)` x只有在y前面才匹配，y不会被计入返回结果。
>  * 先行否定断言`x(!=y)` x只有不在y前面才匹配，y不会被计入返回结果。

## JS中的正则
1. 实例属性  
`RegExp.prototype.lastIndex`,返回一个整数，表示下一次搜索开始的位置。
2.  实例方法  
> * `RegExp.prototype.test()`  返回一个布尔值，表示当前模式是否能匹配到参数字符串,如果带有全局修饰符，正则表达式会记住上一次的lastIndex属性。
> * `RegExp.prototype.exec()`,返回一个数组，第一个成员是匹配的结果，后面的成员是圆括号对应的匹配成功的组。 exec方法返回的数组还包含以下两个属性，`input` 整个原字符串，`index` 整个模式匹配成功的开始位置。如果正则表达式有g修饰符，则可以多次使用exec方法。

## 字符串的实例方法
字符串中有4种实例方法与正则有关
> match, search, replace, split  

1. `match`与正则`exec`方法非常类似，匹配成功返回数组，失败返回null。不同的是，带有g修饰符时，match一次性返回所有匹配成功的结果.
2. `search`返回第一个满足条件的匹配结果在字符串中的位置，如果没有任何匹配则返回-1.
3. `replace`，第一个参数表示搜索模式，第二个参数是替换的内容。第二个参数可以使用美元符号`$`用来指代所替换的内容，第二个参数也可以是函数。
* `$&` 匹配的子字符串
* `$^` 匹配的结果前面的文本
* `$'` 匹配的结果后面的文本
* `$n` 匹配成功的第n组内容，n从1开始
* `$$` 指代美元符号
4. `split` 按照正则分割。